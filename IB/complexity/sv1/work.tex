\input{./infofile.tex}

\documentclass[10pt,\jkfside,a4paper]{article}

\input{../../template/template.tex}

\newcommand{\NP}{\ensuremath{\mathsf{NP}}}
\newcommand{\coNP}{\ensuremath{\mathsf{co-NP}}}

\begin{document}

\section{KuDoS questions}

\begin{enumerate}

\item For functions $f: \mathbb N \to \mathbb N$ and $g: \mathbb N \to
\mathbb N$, what does:

\begin{itemize}

\item $f = \mathcal O(g)$ mean?

Informally: $f$ is eventually bounded above by $g$.

Formally:
\[
f = \mathcal O(g)
\Longleftrightarrow
\exists n_0, c. \forall n \ge n_0. f(n) \le c \cdot g(n)
\]

\item $g = \Omega(g)$ mean?

Informally: $f$ is eventually bounded below by $g$.

Formally:
\[
f = \Omega(g(n))
\Longleftrightarrow
\exists n_0, c. \forall n \ge n_0. f(n) \ge c \cdot g(n)
\]

\end{itemize}

\item What is:

\begin{itemize}

\item A Turing machine?

A Turing machine is a theoretical model of computation based on the idea of
a machine which is in one of a finite internal states uses a head to
read and write from a tape which is ``unbounded to the right'' and upon
which the input is encoded.

Formally, a Turing machine can be represented by a quadruple
$(Q, \Sigma, \delta, s)$, where $Q$ is the set of states, $\Sigma$ is the
set of symbols which can occur on the tapes ($\{\triangleright, \sqcup\}
\subset \Sigma$ are special symbols), $\delta \in Q \times \Sigma \to (Q
\cup \{acc, rej\}) \times \Sigma \times \{L, S, R\}$ is the transition
function and $s$ is the initial state.

\item A configuration of the Turing machine?

A configuration of a Turing machine is a triple $(q, u, v)$ where $q$ is the
state of the Turing machine, $u$ is the string of symbols to the left and
under the tape head and $v$ is the string of symbols to the right which
stretches as far as the last non-blank symbol.

\item A computation of a Turing machine?

A computation of a Turing machine is a finite or infinite sequence of
configurations $c_0 \to_M c_1 \to_M^\star \dots$. Where, for all $i$, $c_i
\to_M c_{i+1}$ is a valid step.

Without loss of generality, let $c_0 = (q, ua, v)$ and $c_1 = (q', u', v'
)$. A transition is valid if and only if $\delta(q, a) = (q', b, D)$ and one
of the following cases holds:
\[
\begin{cases}
D = L, u' = u, v' = bv \\
D = S, u' = ub, v' = v \\
D = R, v = cv'', u = ubc, v' = v'' \\
D = R, v = \varepsilon, u' = ub\sqcup, v' = \varepsilon
\end{cases}
\]

If the computation halts, then it halts in either an accepting state $acc$
or a rejecting state $rej$.

\end{itemize}

\item What does it mean if a language is:

\begin{itemize}

\item Recursively Enumerable?

A language $L$ is Recursively Enumerable if there exists a Turing machine
$M$ such that $L = L(M)$ -- a Turing machine which (when run with
$\triangleright x$ on its input tape) halts in an accepting state if and
only if $x \in L$. Note that the Turing machine may not halt on strings
which are not members of $L$ -- and the number of steps before it halts is
neither computable, nor can it be given an upper bound.

\item Semi-decidable?

Semi-decidable is a simile for Recursively Enumerable.

\item Decidable?

A language $L$ is decidable if and only if there exists a Turing machine
$M$, which (when ran with $\triangleright x$ on its input tape) will reach an
accepting state if and only if $x \in L$; and will reach a rejecting state
if $x \notin L$.

The difference between decidable and semi-decidable is that the machine $M$
halts on all inputs.

\item What does it mean if a function is computable?

A function $f$ is computable if and only if there exists a Turing machine
$M$ which, when started with $\triangleright x$ on the tape, will terminate
in an accepting state $acc$ with $\triangleright y$ on the tape if and only
if $f(x) = y$.

\end{itemize}

\item Define the running time of a turing machine $M$.

The running time of a Turing machine $M$ is a function $r: \mathbb N \to
\mathbb N$ such that $r(n)$ is the most steps required in any halting
computation on an input of length $n$. If \textit{no} computation on an
input of length $n$ halts, then $r(n) = 0$.

\item For any function $f: \mathbb N \to \mathbb N$, what does it mean that
a language $L$ is in $\mathsf{TIME}(f)$?

$L \in \mathsf{TIME}(f)$ means that there exists a Turing Machine $M$ such
that $L = L(M)$ and the running time of $M$ is in $\mathcal O(f)$.

What does it mean that it is in $\mathsf{SPACE}(f)$?

$L \in \mathsf{SPACE}(f)$ means that there exists a Turing Machine $M$ with
a read-only input table and a mutable work-tape such that $M$ goes no more
than $\mathcal O(f)$ cells to the right on the work tape.

\item Give an alternative definition of decidability in terms of the
computability of a function and the $\mathsf{TIME}(\ \cdot\ )$ function.

A language $L$ is decidable if and only if there exists a function $f$ such
that $L \in \mathsf{TIME}(f(n))$.

\item Define the complexity class $\mathsf{P}$

$\mathsf{P}$ is the class of languages which are accepted by a deterministic
Turing Machine in polynomial time. This is formally described below:

\[
\mathsf P = \bigcup_{k \in \mathbb N} \mathsf{TIME}(n^k)
\]

\item What is the $\mathsf{SAT}$ language?

$\mathsf{SAT}$ is the language consisting of boolean expressions which are
satisfiable.

\item What is a verifier $V$ for a language $L$?

A verifier $V$ for a language $L$ is a Turing machine which, when started
with $\triangleright x,c$ will accept if and only if $c$is a certificate of
membership for $x$ being a member of $L$; and will reject the input if $c$
is not a certificate for $x$ being in $L$.

This does not \textit{determine membership of $L$} -- intuitively it checks
whether an encoding of a proof of membership (a certificate $c$) is valid.

\item What is a non-deterministic Turing machine?

A non-deterministic Turing machine is a Turing machine for which the
transition function is not a function; but a relation --
$\delta \in Q \times \Sigma \rightharpoonup (Q \cup \{acc, rej\}) \times
\Sigma \times \{L, U, R\}$. This means the machine could be in one of an
exponential number of possible configurations. The non-deterministic Turing
machine is said to accept the string if \textit{any} of those
possible configurations are accepting.

\item Wha is a reduction of a language $L_1$ to a langauge $L_2$?

Informally, a reduction is a function $f$ which maps strings in the language
$L_1$ to strings in the language; and strings \textit{not} in the language
$L_1$ to strings which are not in the language $L_2$.

A reduction from a language $L_1 \subseteq \Sigma^*$ to a langauge
$L_2 \subseteq \Sigma^*$ is a function $f: \Sigma^* \to \Sigma^*$ which
satisfies the property:
\[
\begin{cases}
f(x) \in L_2 & \text{ if } x \in L_1 \\
f(x) \notin L_2 & \text{ if } x \notin L_1 \\
\end{cases}
\]

\item What does it mean for a language $L$ to be \NP-hard?

Informally: a language $L$is \NP-hard if it is harder than all languages in
\NP.

Formally: a language $L$ is \NP-hard if and only if, $\forall A \in \NP. A
\le_P L$ -- ``for all $A$ in \NP, there is a polynomial time reduction from $A$
to $L$.

What does it mean for a language $L$ to be \NP-complete?

A language $L$ is \NP-complete if and only if it is both in \NP\ and \NP-hard.

\end{enumerate}

\begin{examquestion}{2018}{6}{3}

\begin{enumerate}[label=(\alph*)]

\item Give a precise definition of each of the complexity classes
\NP\ and \coNP.

A language $L$ is in \NP\ if and only if there exists a nondeterministic Turing
machine $M$ such that $L(M) = L$.

A language $L$ is in \coNP if and only if there exists a nondeterministic
Turing machine $M$ such that $L(M) = \bar L \triangleq \{x | x \notin L\}$.

\item Give an example of the following, in each case giving a precise
statement of the decision problem involved.

\begin{enumerate}[label=(\roman*)]

\item an \NP-complete language

$\mathsf{SAT}$ is an \NP-complete language. Given a boolean formula (with
free variables), does it hold under some interpretations?

\item a \coNP-complete language

$\mathsf{VAL}$ is a \coNP-complete language. Given a boolean formula (with
some free variables), does it hold under all interpretations?

\end{enumerate}

\item If $A$ and $B$ are the two languages identified in Part $(b)$, give an
example of a language that is polynomial-time reducible to both $A$ and $B$.
Justify your answer.

I give $\Sigma^*$ -- the language that accepts every string. I present a
reduction from $\Sigma^*$ to $\mathsf{SAT}$ and from $\Sigma^*$ to
$\mathsf{VAL}$.

In polynomial time, we can form the boolean expression $\mathbf{true}$. This
meets the criteria for a polynomial-time reduction from $\Sigma^*\le_P
\mathsf{SAT}$.
\begin{align*}
x \in \Sigma^* &\Longrightarrow f(x) \in \mathsf{SAT} &
x \notin \Sigma^* &\Longrightarrow f(x) \notin \mathsf{SAT} \\
\mathbf{true} &\Longrightarrow \mathbf{true} \in \mathsf{SAT} &
\mathbf{false} &\Longrightarrow \dots \\
\mathbf{true} &\Longrightarrow \mathbf{true} &
\mathbf{true} \\
\mathbf{true}
\end{align*}

In polynomial time, we can form the boolean expression $\mathbf{true}$. This
meets the criteria for a polynomial-time reduction from $\Sigma^*\le_P
\mathsf{VAL}$.
\begin{align*}
x \in \Sigma^* &\Longrightarrow f(x) \in \mathsf{VAL} &
x \notin \Sigma^* &\Longrightarrow f(x) \notin \mathsf{VAL} \\
\mathbf{true} &\Longrightarrow \mathbf{true} \in \mathsf{VAL} &
\mathbf{false} &\Longrightarrow \dots \\
\mathbf{true} &\Longrightarrow \mathbf{true} &
\mathbf{true} \\
\mathbf{true}
\end{align*}

So $\Sigma^*$ is polynomially reducible to both $\mathsf{SAT}$ and
$\mathsf{VAL}$. Any language $L \in \mathsf{P}$ is polynomially reducible
to both $\mathsf{SAT}$ and $\mathsf{VAL}$ by the algorithm which decides
the language and maps $x \in L$ to $\mathbf{true}$ and $x \notin L$ to
$\mathbf{false}$.

\end{enumerate}

\end{examquestion}

\begin{examquestion}{2014}{6}{1}

\begin{enumerate}[label=(\alph*)]

\item Give two definitions of the complexity class \NP, one using
the term Turing machine and one using the term verifier.

\begin{itemize}

\item Turing machine definition

\NP\ is the class of languages which can be accepted in polynomial
time by a nondeterministic Turing machine:
$\NP = \bigcup_{k \in \mathbb N} \mathsf{NTIME}(n^k)$

\item Verifier definition

\NP\ is the class of languages which can be polynomially verified (by a
deterministic Turing machine). Polynomially verifiable means there exists a
verifier $V$ for language $L$ in time polynomial in $x$.

\end{itemize}

\item For each of the following statements, state whether it is true, false
or unknown. In each case, give justification for your answer. In particular,
if the truth statement is unknown, state any implications that might follow
from it being true or false.

\begin{enumerate}[label=(\roman*)]

\item $\mathsf{3SAT} \le_P \mathsf{CLIQUE}$

This is true. I provide an indirect reduction. From $\mathsf{3SAT}$ to
$\mathsf{IND}$ and from $\mathsf{IND}$ to $\mathsf{CLIQUE}$.

A polynomial-time reduction from $\mathsf{3SAT}$ to $\mathsf{IND}$ was given in
the lecture notes.

A polynomial-time reduction from $\mathsf{IND}$ to $\mathsf{CLIQUE}$ takes
the complement of the graph -- this is linear and hence is in $\mathsf{P}$.

\item $\mathsf{TSP} \in \mathsf{P}$

This is unknown. Since the travelling salesman problem is \textbf{not} known
to be either \NP-complete or \NP-hard, this would not prove $\mathsf{P} =
\NP$.

\item $\mathsf{NL} \subseteq \mathsf{P}$

This is true. It's possible to simulate an algorithm which runs in
$\mathsf{NSPACE}(f(n))$ on a deterministic Turing machine which in
$\mathsf{TIME}(k^{\lg n + f(n)})$ for some $k$. $\mathsf{NL}$ is the set of
problems which are solvable in $\mathsf{NTIME}(\lg n)$. Therefore, they can
be simulated by a deterministic Turing machine in $\mathsf{TIME}(k^{\lg n +
\lg n}) = \mathsf{TIME(k^{\lg n})} = \mathsf{TIME}(n^{\lg k})$. This is in
$\mathsf{P}$. Therefore, all problems which are in $\mathsf{NL}$ are
also in $\mathsf{P}$. So $\mathsf{NL} \subseteq \mathsf{P}$.

\item $\mathsf{PSPACE} \neq \mathsf{NPSPACE}$

This is false.

Using Savitch's Theorem, $\mathsf{NSPACE}(f(n)) \subseteq \mathsf{SPACE}(f
(n)^2)$. Using the definitions of $\mathsf{NPSPACE}$ and $\mathsf{PSPACE}$,
we have:
\begin{align*}
\mathsf{NPSPACE} &= \bigcup_{k \in \mathbb N} \mathsf{NSPACE}(n^k) \\
&\subseteq \bigcup_{k \in \mathbb N} \mathsf{SPACE}(n^{2k}) \\
&\subseteq \bigcup_{k \in \mathbb N} \mathsf{SPACE}(n^{k}) \\
&\subseteq \mathsf{PSPACE}
\end{align*}
We also have from the space hierarchy theorem that $\mathsf{PSPACE} \subseteq
\mathsf{NPSPACE}$. Therefore $\mathsf{PSPACE} = \mathsf{NPSPACE}$.

\end{enumerate}

\item Let $\Sigma = \{0, 1\}$. Prove that $\emptyset$ and $\{0, 1\}^*$ are the
only languages in $\mathsf{P}$ which are not complete for $\mathsf{P}$ with
respect to polynomial time reductions.

\begin{itemize}

\item Assume that $L \in \mathsf P$ and $\exists x, y. x \in L, y \notin L$.
This is the set of languages $L \in \mathsf P \setminus \{\emptyset,
\{0, 1\}^*\}$.

To prove that $L$ is complete for $\mathsf P$, we must prove that for any
arbitrary language $L' \in \mathsf{P}$, $L' \le_P L$.

Define $f$ as follows:
\[
f(z) =
\begin{cases}
x & \text{ if } z \in L' \\
y & \text{ if } z \notin L'
\end{cases}
\]

Since $L' \in \mathsf{P}$, we have that $L'$ can be recognised in polynomial
time. So $f$ performs a polynomial-time computation then a constant
amount of work (writing $x$ or $y$ onto the tape) -- $f \in \mathsf P$. Since
$f$ is a reduction and $L'$ was arbitrary, we can conclude that $\forall L'
\in \mathsf P. L' \le_P L$.

Therefore, all langauges $L \in \mathsf P$ except for $\emptyset$ and $\{0, 1
\}$ are complete for $\mathsf P$ with respect to polynomial-time reductions.

\item Let $L = \emptyset$

The language $\{1\}$ is in $\mathsf P$.

Assume that there is a reduction from $\{1\}$ to $\emptyset$.
So there exists some $f$ such that $f(1) \in \emptyset$. This is a
contradiction! There are no elements in the empty set -- so there can be no
reduction from $\{1\}$ to $\emptyset$. Hence $\emptyset$ is not $\mathsf
P$-complete.

\item Let $L = \{0, 1\}^*$

The language $\{1\}$ is in $\mathsf P$.

Assume there is a reduction from $\{1\}$ to $\{0, 1\}^*$. So there exists
some $f$ such that $f(0) \notin \{0, 1\}^*$. This is a contradiction -- by
definition, $\forall x \in \Sigma^*. x \in \{0, 1\}^*$. Therefore, the
assumption that there exists a polynomial-time reduction from $\{1\}$ to
$\{0, 1\}$ must be false. Hence $\{0, 1\}$ is not $\mathsf P$-complete.

\end{itemize}

Hence, all languages in $\mathsf P$ except for $\emptyset$ and $\{0, 1\}^*$
are complete for $\mathsf P$ with respect to polynomial-time reductions. As
required.

\end{enumerate}

\end{examquestion}

\begin{examquestion}{2012}{6}{1}

\begin{enumerate}[label=(\alph*)]

\item Suppose $L_1$ and $L_2$ are languages in $\mathsf{P}$. What can you
say about the complexity of each of the following? Justify your answer in
each case.

\begin{enumerate}[label=(\roman*)]

\item $L_1 \cup L_2$

$L_1 \cup L_2 \in \mathsf{P}$. A Turing machine which recognises $L_1 \cup
L_2$ in polynomial time can be formed by starting with the machine which
recognises $L_1$, then running the machine which recognises $L_2$. If
\textbf{either} machines reach an accepting state then accept. We run two
polynomial-time algorithms, the new machine also terminates in
polynomial-time.

\item $L_1 \cap L_2$

$L_1 \cap L_2 \in \mathsf{P}$. A Turing machine which recognises $L_1 \cap
L_2$ in polynomial time can be formed by starting with the machine which
recognises $L_1$, then running the machine which recognises $L_2$. If
\textbf{both} machines reach accepting states, then accept. Since we run two
polynomial-time algorithms, the new machine also terminates in
polynomial-time.

\item The complement of $L_1$

$\bar{L_1} \in \mathsf{P}$. The complexity class $\mathsf{P}$ is closed
under complementation. Given a machine $(Q, \Sigma, \delta, s)$ which
recognises $L_1$ in polynomial time, the machine $M'$ defined as
$(Q, \Sigma, \delta', s)$ will recognise $\bar L$ in polynomial time; where
$\delta'$ swaps transitions into $rej$ with transitions into $acc$; and
swaps transitions into $acc$ with transitions into $rej$. $\delta'$ is defined
as:
\begin{align*}
\delta' = &\{((q, a), (q', b, d))\ |\ ((q, a), (q', b, d)) \in \delta, q'
\notin \{acc, rej\}\} \\
\cup &\{((q, a), (acc, b, d))\ |\ ((q, a), (rej, b, d)) \in \delta\} \\
\cup &\{((q, a), (rej, b, d))\ |\ ((q, a), (acc, b, d)) \in \delta\}
\end{align*}

\end{enumerate}

\item Suppose $L_1$ and $L_2$ are languages in \NP. What can you say about
the complexity of each of the following? Justify your answer in each case.

\begin{enumerate}[label=(\roman*)]

\item $L_1 \cup L_2$

This language is also in \NP. Given machines
$M_1 = (Q_1, \Sigma_1, \delta_1, s)$
and $M_2 = (Q_2, \Sigma_2, \delta_2, s)$ such that $L(M_1) = L_1$ and
$L(M_2) = L_2$; the machine $M' = (Q_1 \cup Q_2, \Sigma_1 \cup \Sigma_2,
\delta_1 \cup \delta_2, s)$ recognises the language $L_1 \cup L_2$.

\item $L_1 \cap L_2$

This language is also in \NP. Given machines
$M_1 = (Q_1, \Sigma_1, \delta_1, s)$
and $M_2 = (Q_2, \Sigma_2, \delta_2, s)$ such that $L(M_1) = L_1$ and
$L(M_2) = L_2$; we can form a Turing machine which recognises the language
$L_1 \cap L_2$ by running them sequentially and accepting if and only if
both machines accept.

\item The complement of $L_1$

$\bar{L_1} \in \coNP$. By definition, the complexity class \coNP is the
class of languages which are polynomially falsifiable. So $\bar{L_1} \in
\coNP$.

\end{enumerate}

\item Give an example of a language in \NP\ that is \textit{not} \NP-complete
and prove that it is not.

I give the language $\emptyset$, which accepts no strings. Clearly, this is
decidable in polynomial time by the nondeterministic Turing machine which
immediately accepts:
$(\{s\}, \Sigma, \{((\triangleright, s), (acc, \triangleright, R)), s\})$.
Therefore, $\emptyset \in \NP$.

I prove by contradiction that $\emptyset \notin \NP\text{-complete}$.

Assume for contradiction that $\emptyset \in \NP\text{-complete}$

So for every $A \in \NP$, $A \le_P \emptyset$.

Clearly $\Sigma^* \in \NP$. So by the definition of $\NP$-completeness,
$\Sigma^*\le_P \emptyset$.
\begin{align*}
\Sigma^* \le_P \emptyset &\Longrightarrow \\
\exists f. \forall x. (x \in \Sigma^* \Longleftrightarrow f(x) \in \emptyset)
&\Longrightarrow \\
\exists f. \forall x. (x \in \Sigma^* \Longrightarrow f(x) \in \emptyset)
&\Longrightarrow \\
\exists f. \forall x. (\mathbf{true} \Longrightarrow f(x) \in \emptyset)
&\Longrightarrow \\
\exists f. \forall x. f(x) \in \emptyset &
\end{align*}
This is a contradiction! By the definition of $\emptyset$, $\forall x. x
\notin \emptyset$. Since we have reached a contradiction, our original
assumption that $\emptyset$ was \NP-complete must have been wrong and
therefore $\emptyset \notin \NP\text{-complete}$

\end{enumerate}

\end{examquestion}

\end{document}
