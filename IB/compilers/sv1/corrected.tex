\input{./infofile.tex}

\documentclass[10pt,\jkfside,a4paper]{article}

\input{../../template/template.tex}

\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,automata,petri,positioning}

\begin{document}

\begin{examquestion}{2004}{4}{1}

\begin{enumerate}

\item A context-free grammar can be formally defined as a 4-tuple. Give a 
precise statement of what the components are
\[
G = (N, T, P, S)
\]

\begin{itemize}

\item $G$ is the grammar

\item $N$ is the set of nonterminals

A Nonterminal is an internal symbol. These represent concepts such as
expressions or statements.

\item $T$ is the set of terminals

A Terminal is a token passed to the parser by the lexer. These may
correspond to an individual literal or a sequence of literals. Terminals are
indivisible. The input to any PDA is a sequence of terminals.

\item $P \subseteq N \times (N \cup T)*$ is the set of productions

A production is of the form $A \to \alpha$ and says that it is legal for any
occurrence of $A$ to be replaced with $\alpha$ at any point.

\item $S \in N$ is the start symbol

\end{itemize}

Note also that $N$, $T$ and $P$ are finite; and that $N \cup T = \emptyset$.

\item Explain the difference between a grammar and the language it generates.

A grammar is a set of rules which is used to generate a language.

The language generated by a grammar is a set of strings.

Each grammar generates exactly one language, however a given language may be
generated by many grammars.

A grammar is finite, while a language is infinite and a language is flat
while a grammar is structured.

\item Explain what makes a grammar ambiguous, with reference to the grammar 
which may commonly be expressed as a ``rule''
\[
E \Coloneqq 1 \ | \ 2 \ | \ X \ | \ E + E \ | \ E * E \ | \ - E
\]
where $X$ is an identifier

A grammar is ambiguous if there exists any string for which there are
multiple leftmost derivations for the grammar to generate that string.
Consider the string $1 + 2 * X$ with the grammar above.

Under the grammar above, there are two possible parse trees for $1 + 2 * X$
and therefore the grammar is ambiguous.

\begin{center}
\begin{tikzpicture}
\node (start) {$E$};
\node (leftplus) [below left = of start] {$E$};
\node (times) [below = of start] {$*$};
\node (righte) [below right = of start] {$E$};
\path [->] (start) edge (leftplus);
\path [->] (start) edge (times);
\path [->] (start) edge (righte);
\node (l2E) [below left = of leftplus] {$E$};
\node (r2E) [below right = of leftplus] {$E$};
\node (plus) [below = of leftplus] {$+$};
\path [->] (leftplus) edge (l2E);
\path [->] (leftplus) edge (r2E);
\path [->] (leftplus) edge (plus);
\node (n1) [below = of l2E] {$1$};
\node (n2) [below = of r2E] {$2$};
\node (nx) [below = of righte] {$X$};
\path [->] (l2E) edge (n1);
\path [->] (r2E) edge (n2);
\path [->] (righte) edge (nx);
\end{tikzpicture}
\hspace{2cm}
\begin{tikzpicture}
\node (start) {$E$};
\node (leftplus) [below right = of start] {$E$};
\node (times) [below = of start] {$+$};
\node (righte) [below left = of start] {$E$};
\path [->] (start) edge (leftplus);
\path [->] (start) edge (times);
\path [->] (start) edge (righte);
\node (l2E) [below left = of leftplus] {$E$};
\node (r2E) [below right = of leftplus] {$E$};
\node (plus) [below = of leftplus] {$*$};
\path [->] (leftplus) edge (l2E);
\path [->] (leftplus) edge (r2E);
\path [->] (leftplus) edge (plus);
\node (n1) [below = of l2E] {$2$};
\node (n2) [below = of r2E] {$X$};
\node (nx) [below = of righte] {$1$};
\path [->] (l2E) edge (n1);
\path [->] (r2E) edge (n2);
\path [->] (righte) edge (nx);
\end{tikzpicture}
\end{center}

\item For the ``rule'' in part (c), give a formal grammar containing this
``rule'' and adhering to your definition in part (a).
\[
\begin{split}
G = (&\{E\}, \\
&\{1, 2, X, *, +\}, \\
&\{(E, 1), (E', 2), (E', X), (E, E + E), (E, E * E), (E, -E)\}, \\
&E)
\end{split}
\]
\begin{align*}
E  &\Coloneqq T \ E' \\
E' &\Coloneqq +T \ E' \ | \ *T \ E' \ | \ \varepsilon \\
T  &\Coloneqq N \ | \ -T \\
N  &\Coloneqq 1 \ | \ 2 \ | \ X
\end{align*}

\item Give non-ambiguous grammars each generating the same language as your
grammar in part (d) for the cases:

\begin{enumerate}

\item ``$-$`` is most tightly binding and ``$+$'' and ``$*$'' have equal
binding power and associate to the left.
\[
\begin{split}
G_1 = (&\{E, E', N, T\}, \\
	   &\{1, 2, X, *, +\}, \\
	   &\{(E, E'T), (E', E'T+), (E', E'T*), (E', \varepsilon), (T, N), (T,
	   -T), (N, 1), (N, 2), (N, X)\}, \\
	   &E)
\end{split}
\]
\begin{align*}
E  &\Coloneqq E' \ T \\
E' &\Coloneqq E' \ T+ \ | \ E' \ T* \ | \ \varepsilon \\
T  &\Coloneqq N \ | \ -T \\
N  &\Coloneqq 1 \ | \ 2 \ | \ X
\end{align*}

\item ``$-$'' is most tightly binding and ``$+$'' and ``$*$'' have equal
binding power and associate to the right.
\[
\begin{split}
G_2 = (&\{E, E', N, T\}, \\
	   &\{1, 2, X, *, +\}, \\
	   &\{(E, TE'), (E', +TE'), (E', *TE'), (E', \varepsilon), (T, N), (T,
	   -T), (N, 1), (N, 2), (N, X)\}, \\
	   &E) \\
\end{split}
\]
\begin{align*}
E  &\Coloneqq T \ E' \\
E' &\Coloneqq +T \ E' \ | \ *T \ E' \ | \ \varepsilon \\
T  &\Coloneqq N \ | \ -T \\
N  &\Coloneqq 1 \ | \ 2 \ | \ X
\end{align*}

\item ``$-$'' binds more tightly than ``$+$'', but less tightly than
``$*$'', with ``$+$'' left-associative and ``$*$'' right-associative so that
``$-a + -b * c * c + d$'' is associated as ``$((-a) + (-(b * (c * d)))) + d$''.
\[
\begin{split}
G_3 = (&\{E, E', T, F, F', N\}, \\
	   &\{1, 2, X, *, +\}, \\
	   &\{(E, E'T), (E', E'T+), (E',\varepsilon), (T, F), (T, -T), (F, NF'),
	    (F', *NF'), (F', \varepsilon), (N, 1), (N, 2), (N, X)\}, \\
	   &E) \\
\end{split}
\]
\begin{align*}
E &\Coloneqq E'\ T \\
E'&\Coloneqq E' \ T + \ | \ \varepsilon \\
T &\Coloneqq F \ | \ -T \\
F &\Coloneqq N \ F' \\
F' &\Coloneqq *N \ F' \ | \ \varepsilon \\
N &\Coloneqq 1 \ | \ 2 \ | \ X
\end{align*}

\end{enumerate}

\item Give a simple recursive descent parser for your grammar in part (e)(iii)
above which yields a value of type \texttt{ParseTree}. You may assume
operations \textit{mkplus}, \textit{mktimes}, \textit{mkneg} acting on type
\texttt{ParseTree}.

\begin{lstlisting}[language=Caml]
type n = E | E' | T | F | F' | N

type t = Plus | Minus | Times | 1 | 2 | X | Epsilon

let parse ts =
	let parseE ts =
		let pt, ts = parseT ts in
		parseE' pt ts
	in
	let parseE' pt1 = function
		| Plus::ts -> (
			let pt2, ts = parseT ts in
			match ts with
			| Plus::ts -> (
				let pt2, ts = (parseT pt (Plus::ts)) in
				parseE' (mkplus pt1 pt2) ts
				)
			| _ -> pt, ts
			)
		| ts -> pt1
	in
	let parseT = function
		| Minus::ts -> (
			let pt, ts = parseT ts in
			(mkminus pt), ts
			)
		| ts -> parseF ts
	in
	let parseF ts =
		let pt, ts = parseN ts in
		parseF' pt ts
	in
	let parseF' pt1 = function
		| Times::ts -> (
			let pt2, ts = parseN ts in
			parseF' (mktimes pt1 pt2) ts
			)
		| ts -> pt1, ts
	in
	match parseE ts with
	| _, [] -> raise ParseException
	| pt, _ -> pt
\end{lstlisting}

\iffalse

\begin{lstlisting}[language=Caml, mathescape=||]

(* I assume mkplus rotates the tree such that plus is left-associative *)
(* I assume mkneg pulls all -'s up until they are at the correct precedence *)

type n = E | E' | A | T | T' | N

type t = + | - | 1 | 2 | X

type parseTree = E_P1 of parseTree * parseTree
		| E'_P1 of t * parseTree * parseTree
		| E'_P2 of Epsilon
		| ...

let parse ts =
	let rec parse ts, n =
		match ts with
		| [] ->
			if n != E' and n != T' then
				raise ParseException
		| Plus::ts ->
			match n with
			| E' ->
				let pt1, ts = parse ts T in
				let pt2, ts = parse ts E' in
				(E'_P1 Plus pt1 pt2), ts
			| _ ->
				raise ParseException
		| Minus::ts ->
			match n with
			| E ->
				let pt, ts = parse ts T in
				(E_P1 Minus pt), ts
			| T ->
				let pt, ts = parse ts N in
				(T_P2 Minus pt), ts
			| _ ->
				raise ParseException
		| x::ts when x = 1 || x = 2 || x = X ->
			match n with
			| N -> N_P1, ts
			| T -> (T_P1 N_P1), ts
			| E ->
				let pt1, ts = parse ts, T in
				let pt2, ts = parse ts, E' in
				(E_P1 x pt1 pt2), ts
			| _ -> raise ParseException
	in
	match parse ts E in with
	| pt, [] -> mkplus (mkminus (mktimes pt))
	| _ -> raise ParseException
;;


\end{lstlisting}

\fi

\end{enumerate}

\end{examquestion}

\begin{examquestion}{2002}{4}{2}

The specification for a pocket-calculator-style programming language is as 
follows:

\begin{itemize}

\item Valid inputs consist either of an Expression followed by the
\framebox{enter} button of of an Expression followed by \framebox{store}
Identifier \framebox{enter};

\item Expressions consist of Numbers and Identifiers connected with the
binary operators \framebox{$+$}, \framebox{$\times$} and
\framebox{$\uparrow$} (in increasing binding power), with the Unary operators
\framebox{$-$} and \framebox{abs}, and possibly grouped with parentheses.
Unary operators bind more strongly than \framebox{$+$} but weaker than
\framebox{$\times$} so that $-a + b$ means $(-a) + b$ but $-a \times b$
means $-(a \times b)$.

\item Numbers consist of a sequence of at least one digit, possibly
interspersed with exactly one decimal point, and possibly followed by an
exponential marker ``$e$'' followed by a signed integer, e.g. $6.023e+22$.
Identifiers are sequences of lower-case letters.

\end{itemize}

\begin{enumerate}

\newcommand{\Start}{\mathbf{Start}}
\newcommand{\Unary}{\mathbf{Unary}}
\newcommand{\OptUnary}{\ \mathbf{OptUnary}}
\newcommand{\OptExpression}{\mathbf{OptExpression}}
\newcommand{\Expression}{\mathbf{Expression}}
\newcommand{\Times}{\mathbf{Times}}
\newcommand{\OptTimes}{\mathbf{OptTimes}}
\newcommand{\Arrow}{\mathbf{Power}}
\newcommand{\OptArrow}{\mathbf{OptPower}}
\newcommand{\Value}{\mathbf{Value}}
\newcommand{\Identifier}{\mathbf{Identifier}}
\newcommand{\OptIdentifier}{\mathbf{OptIdentifier}}
\newcommand{\Letter}{\mathbf{Letter}}
\newcommand{\Number}{\mathbf{Number}}
\newcommand{\Int}{\mathbf{Int}}
\newcommand{\OptInt}{\mathbf{OptInt}}
\newcommand{\OptDecimal}{\mathbf{OptDecimal}}
\newcommand{\OptSuffix}{\mathbf{OptSuffix}}
\newcommand{\Sign}{\mathbf{Sign}}

\item Give a Context-Free Grammar for the set of valid input sequences using
names beginning with an upper-case letter for non-terminals. It should be
complete in that you should go as far as to define e.g.
\[
\mathbf{Letter} \Coloneqq \mathbf{a} \ | \ \mathbf{b} \ | \ \mathbf{c} \ |
\ \dots \ | \ \mathbf{z}
\]
\begin{align*}
\Start &\Coloneqq \Expression \ \framebox{enter} \ | \ \Expression \
\framebox{store} \ \Identifier \ \framebox{enter} \\
\Expression &\Coloneqq \Unary \ \OptExpression \\
\OptExpression &\Coloneqq \framebox{$+$} \ \Unary \ \OptExpression \ | \
\varepsilon \\
\Unary &\Coloneqq \Times \ | \ \framebox{$-$} \ \Unary \ | \ \framebox{abs} \
\Unary \\
\Times &\Coloneqq \Arrow \ \OptTimes \\
\OptTimes &\Coloneqq \framebox{$\times$} \ \Unary \ \OptTimes \ | \
\varepsilon\\
\Arrow &\Coloneqq \Value \ \OptArrow \\
\OptArrow &\Coloneqq \framebox{$\uparrow$} \ \OptUnary \ | \ \varepsilon \\
\OptUnary &\Coloneq \framebox{$-$} \ \OptUnary \ | \ \framebox{abs} \
\OptUnary \ | \ \Arrow \\
\Value &\Coloneqq (\Expression) \ | \ \Identifier \ | \ \Number \\
\Identifier &\Coloneqq \Letter \ \OptIdentifier \\
\OptIdentifier &\Coloneqq \Letter \ \OptIdentifier \ | \ \varepsilon \\
\Letter &\Coloneqq \mathbf{a} \ | \ \mathbf{b} \ | \ \mathbf{c} \ | \ \dots \
 | \ \mathbf{z} \\
\Number &\Coloneqq \Int \ \OptInt \ \OptDecimal \ \OptSuffix \ | \
\framebox{$.$} \ \Int \ \OptInt \ \OptSuffix \\
\Int &\Coloneqq 0 \ | \ 1 \ | \ \dots \ | \ 9 \\
\OptInt &\Coloneqq \Int \ \OptInt \ | \ \varepsilon \\
\OptDecimal &\Coloneqq \framebox{$.$} \ \OptInt \ | \ \varepsilon \\
\OptSuffix &\Coloneqq \mathbf{e} \ \Sign \ \Int \ \OptInt \\
\Sign &\Coloneqq \framebox{$+$} \ | \ \framebox{$-$} \\
\end{align*}

\item Indicate, giving brief reasoning, which non-terminals are appropriate
to be processed using lexical analysis and for which using syntax analysis
is proper.

It's appropriate to process $\Value$, $\Identifier$, $\OptIdentifier$,
$\Letter$, $\Number$, $\Int$, $\OptInt$, $\OptDecimal$, $\OptSuffix$ and
$\Sign$ in lexical analysis. This is because the langauge which these
non-terminals can match is regular and there is no binding tightness to
consider. Therefore, it's appropriate to process them during lexing.

\item Give yacc or CUP input describing those elements deemed in part (b) to
be suitable for syntax analysis. You need not give ``semantic actions''.

\begin{lstlisting}[language=C, escapeinside=()]

%token Start Expression OptExpression Unary Times OptTimes Arrow OptArrow

%right '+'
%noassoc '-'
%left '*'
%left '($\uparrow$)'

%%

E 	: v
	| E + E
	| - E
	| E * E
	| E ($\uparrow$) E
	| (E)

\end{lstlisting}

\end{enumerate}

\end{examquestion}

\end{document}
